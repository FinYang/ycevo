
prep_windows <- function(data, xgrid, hx, rgrid, hr, 
                         tau, ht, tau_p, htp, 
                         interest, units, interest_grid){
  # kernel weights on qdatetime
  mat_weights_qdatetime <- get_weights(xgrid, hx, len = length(unique(data$qdate)))
  day_idx <- range_idx_nonzero(mat_weights_qdatetime, threshold = 0)
  nday <- length(xgrid)
  
  # kernel weights on interest
  joint_window <-  NULL
  day_grid <- NULL
  if(interest_grid){
    r_window <- calc_r_window(interest, rgrid, hr)
    day_grid <- expand.grid(ug = xgrid, rg = rgrid)
    nday <- nrow(day_grid)
    joint_window <- matrix(0, nrow(mat_weights_qdatetime), nday)
    for(j in seq_along(rgrid)){
      for(i in seq_along(xgrid)){
        joint_window[, (j-1)*length(xgrid) + i] <- mat_weights_qdatetime[,i] * r_window[,j]
      }
    }
    apply(joint_window, 2, function(y) {
      if(all(y == 0)){
        day_idx <- c(0, 0)
      } else {
        window_idx <- which(y != 0)
        day_idx <- c(window_idx[1], window_idx[length(window_idx)])
      }
      day_idx
    }) %>% t() -> day_idx
    obs <- which(day_idx[,1] != 0)
    day_grid <- day_grid[obs, ]
    joint_window <- joint_window[,obs]
    day_idx <- day_idx[obs, ]
    nday <- length(obs)
    if(nday == 1){
      joint_window <- matrix(joint_window, ncol = 1)
      day_idx <- matrix(day_idx, nrow = 1)
    }
    
  }
  
  # kernel weights on time to maturity
  stopifnot(is.vector(tau))
  mat_weights_tau <- get_weights(tau, ht, 
                                 len = as.integer(max(data$tupq)),
                                 units = units)
  tupq_idx_tau <- range_idx_nonzero(mat_weights_tau, threshold = 0.01)
  ntupq_tau <- length(tau)
  
  stopifnot(is.vector(tau_p))
  mat_weights_tau_p <- get_weights(tau_p, htp, 
                                   len = as.integer(max(data$tupq)),
                                   units = units)
  tupq_idx_tau_p <- range_idx_nonzero(mat_weights_tau_p, threshold = 0.01)
  ntupq_tau_p <- length(tau_p)
  
  
  list(
    # qdatetime
    mat_weights_qdatetime = mat_weights_qdatetime, 
    day_idx = day_idx, 
    nday = nday, 
    # interest
    joint_window = joint_window, 
    # tau
    mat_weights_tau = mat_weights_tau, 
    tupq_idx_tau = tupq_idx_tau, 
    ntupq_tau = ntupq_tau, 
    mat_weights_tau_p = mat_weights_tau_p,
    tupq_idx_tau_p = tupq_idx_tau_p, 
    ntupq_tau_p = ntupq_tau_p, 
    day_grid = day_grid
  )
}



# A component of the \code{estimate_yield} function that calculates \eqn{dbar}
# 
# Internal function that estimates the discount function without taking into account
# cross products of coupon payments. Not to be used independently. Exported for documentation purpose.
# 
# @param data A data frame; bond data to estimate discount curve from. See \code{?USbonds} for an example bond data structure.
# @param xgrid A length T numeric vector; the times at which the discount curve will be estimated.
# @param hx A length T numeric vector, bandwidth parameter determining the size of the window
# that corresponds to each time at which the discount curve is estimated,
# @param rgrid (Optional) A length K numeric vector of interest rate grid values
# @param hr (Optional) A length K numeric vector of interest rate grid bandwidths
# @param tau A length m numeric vector, or either a 1 x x or T x x numeric matrix. If a T x x matrix, each row represents the time-to-maturity grid
# that each time-to-maturity in the discount function is compared against. Otherwise the same time-to-maturity grid is repeated for each of the T xgrid values
# @param ht An numeric vector of length T, or if tau is a matrix, a numeric matrix of the same dimensions as tau.
# A vector ht for a T x m matrix tau repeats values for each row of tau_p.
# bandwidth parameter determining the size of the window that corresponds to each time-to-maturity.
# @param price_slist (Optional) A list of matrices, generated by calc_price_slist.
# @param cf_slist (Optional) A list of matrices, generated by calc_cf_slist.
# @param interest (Optional) A vector of daily short term interest rates
# @param units (Optional) number of tupq per tau (e.g. 365 for daily data with annual grid values). Defaults to 365
# @param unit (Optional) Smallest interval between quotation date time. Class Period. Needs to be by which 365 (days) is divided exactly. 
# 
# @return Data frame with the following variables
# 
# \describe{
#   \item{ug}{Same as input \code{xgrid}}
#   \item{dbar_numer}{Numerator in dbar. See \code{Source}}
#   \item{dbar_denom}{Denominator in dbar. See \code{Source}}
#   \item{xg}{Same as input \code{tau}}
# }
# 
# @source Koo, B., La Vecchia, D., & Linton, O. B. (2019). Estimation of a Nonparametric model for Bond Prices from Cross-section and Time series Information. Available at SSRN3341344.
# @author Nathaniel Tomasetti
# 
calc_dbar <- function(data, xgrid, 
                      tau, 
                      price_slist, cf_slist, 
                      interest_grid, windows_ls) {
  day_idx <- windows_ls$day_idx
  tupq_idx <- windows_ls$tupq_idx_tau
  mat_weights_tau <- windows_ls$mat_weights_tau
  mat_weights_qdatetime <- windows_ls$mat_weights_qdatetime
  joint_window <- windows_ls$joint_window
  ntupq <- windows_ls$ntupq_tau
  nday <- windows_ls$nday
  day_grid <- windows_ls$day_grid
  
  if(interest_grid){
    dbar <- calc_dbar_c3(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, joint_window, price_slist, cf_slist)
    # bench::mark(
    #   calc_dbar_c2(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, joint_window, price_slist, cf_slist),
    #   calc_dbar_c3(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, joint_window, price_slist, cf_slist), # best
    #   calc_dbar_r3(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, joint_window, price_slist, cf_slist),
    #   check=FALSE
    # )[,-1]
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result memory                 time           gc              
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list> <list>                 <list>         <list>          
    # #   1    9.09s    9.09s     0.110    5.18KB     0        1     0      9.09s <NULL> <Rprofmem [978 × 3]>   <bench_tm [1]> <tibble [1 × 3]>
    # #   2  74.34ms  76.48ms    12.9      5.18KB     1.84     7     1   542.12ms <NULL> <Rprofmem [3 × 3]>     <bench_tm [7]> <tibble [7 × 3]>
    # #   3 568.81ms 568.81ms     1.76      2.1GB     3.52     1     2   568.81ms 
    day_grid <- day_grid[rep(1:nday, each=ntupq),]
    dbar <- data.frame(ug = day_grid$ug, rg = day_grid$rg, dbar_numer = dbar[,1], dbar_denom = dbar[,2])
  } else {
    dbar <- calc_dbar_c3(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist)
    
    # price_smat <- do.call(cbind, price_slist)
    # cf_smat <- do.call(cbind, cf_slist)
    # 
    # m1 <- as(mat_weights_tau, "sparseMatrix")
    # m2 <- as(mat_weights_qdatetime, "sparseMatrix")
    # a <- price_smat*cf_smat
    # b <- cf_smat^2
    # 
    # bench::mark(
    # # calc_dbar_c(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist),
    # calc_dbar_c2(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist),
    # calc_dbar_c3(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist), # best
    # # calc_dbar_r(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist),
    # # calc_dbar_r2(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist),
    # # calc_dbar_r3(nday, ntupq, day_idx, tupq_idx, mat_weights_tau, mat_weights_qdatetime, price_slist, cf_slist),
    # # calc_dbar_r4(mat_weights_tau, mat_weights_qdatetime, price_smat, cf_smat),
    # # calc_dbar_m(m1,m2, price_smat, cf_smat),
    # # calc_dbar_m2(m1,mat_weights_qdatetime, a, b),
    # )[,-1]
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>
    # #   1 328.98µs 333.04µs   2916.      2.49KB     2.00  1458     1      500ms <NULL>
    # #   2 318.53µs 324.29µs   3019.      2.49KB     0     1510     0      500ms <NULL>
    # #   3  56.91µs  58.18µs  16737.      2.49KB     0     8363     0      500ms <NULL>
    # #   4 373.15ms 377.52ms      2.65        0B     6.62     2     5      755ms <NULL>
    # #   5   2.38ms   2.56ms    364.     70.63KB     5.99   182     3      500ms <NULL>
    # #   6 478.14µs 505.28µs   1794.     94.14KB     5.99   898     3      500ms <NULL>
    # #   7 817.38µs 858.95µs   1076.     83.08KB     3.99   539     2      501ms <NULL>
    # #   8 539.85µs 543.29µs   1781.      2.49KB     2.00   891     1      500ms <NULL>
    # #   9 488.02µs 490.44µs   2004.      2.49KB     0     1002     0      500ms <NULL>
    
    # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result memory             time       gc      
    # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list> <list>             <list>     <list>  
    #   c2    9.88s    9.88s     0.101    5.18KB    0.101     1     1      9.88s <NULL> <Rprofmem>         <bench_tm> <tibble>
    #   c3  69.8ms  71.07ms     8.76     5.18KB    0         5     0    570.8ms <NULL> <Rprofmem [3 × 3]> <bench_tm> <tibble>
    #   r3  575.6ms  575.6ms     1.74      2.1GB    3.47      1     2    575.6ms
    dbar <- data.frame(ug = rep(xgrid, rep(ntupq, nday)), dbar_numer = dbar[,1], dbar_denom = dbar[,2])
  }
  dbar$xg <- rep(tau, nday)
  dbar
}

# A component of the \code{estimate_yield} function that calculates \eqn{hhat}
# 
# Internal function that calculates coupon payment cross products. 
# Not to be used independently. Exported for documentation purpose.
# 
# @param data A data frame; bond data to estimate discount curve from. See \code{?USbonds} for an example bond data structure.
# @param xgrid A length T numeric vector; the times at which the discount curve will be estimated.
# @param hx A length T numeric vector, bandwidth parameter determining the size of the window
# that corresponds to each time at which the discount curve is estimated,
# @param rgrid (Optional) A length K numeric vector of interest rate grid values
# @param hr (Optional) A length K numeric vector of interest rate grid bandwidths
# @param tau A length m numeric vector, or either a 1 x m or T x m numeric matrix. If a T x m matrix, each row represents the time-to-maturity grid
# for the discount function at the corresponding time. Otherwise the same time-to-maturity grid is repeated for each of the T xgrid values
# @param ht An numeric vector of length T, or if tau is a matrix, a numeric matrix of the same dimensions as tau.
# A vector ht for a T x m matrix tau_p repeats values for each row of tau.
# bandwidth parameter determining the size of the window that corresponds to each time-to-maturity.
# @param tau_p (Optional), A length m numeric vector, or either a 1 x m or T x m numeric matrix, matching tau input with m allowed to be different to M.
# If a T x m matrix, each row represents the time-to-maturity grid that each time-to-maturity in the discount function is compared against.
# Otherwise the same time-to-maturity grid is repeated for each of the T xgrid values.
# If m = M, and each entry of tau_p is identical to tau, estimation is performed without interpolaton of the h-hat matrix.
# If the entries are not identical each entry of each row of tau_p must be within the range from the smallest to largest value of the corresponding row of tau,
# and linear interpolation of the h-hat matrix is performed.
# If omitted, tau_p is set equal to tau.
# @param htp (Optional) An numeric vector of length T, or if tau_p is a matrix, a numeric matrix of the same dimensions as tau_p.
# A vector htp for a T x M matrix tau_p repeats values for each row of tau_p.
# bandwidth parameter determining the size of the window that corresponds to each time-to-maturity.
# If omitted, htp is set equal to ht
# @param cf_slist (Optional) A list of matrices, generated by calc_cf_slist.
# @param interest (Optional) A vector of daily short term interest rates
# @param units (Optional) number of tupq per tau (e.g. 365 for daily data with annual grid values). Defaults to 365
# 
# @return Data frame with the following variables
# 
# \describe{
#   \item{hhat_numer}{Numerator in H hat. See \code{Source}}
#   \item{ug}{Same as input \code{xgrid}}
#   \item{xg}{Same as input \code{tau}}
#   \item{qg}{Same as input \code{tau_p}}
# }
# 
# @author Nathaniel Tomasetti
# @source Koo, B., La Vecchia, D., & Linton, O. B. (2019). Estimation of a Nonparametric model for Bond Prices from Cross-section and Time series Information. Available at SSRN3341344.
# 
calc_hhat_num <- function(data, xgrid, 
                          tau, 
                          tau_p = tau, 
                          cf_slist = NULL, 
                          interest_grid, windows_ls) {
  day_idx <- windows_ls$day_idx
  tupq_idx_tau <- windows_ls$tupq_idx_tau
  tupq_idx_tau_p <- windows_ls$tupq_idx_tau_p
  mat_weights_tau <- windows_ls$mat_weights_tau
  mat_weights_qdatetime <- windows_ls$mat_weights_qdatetime
  mat_weights_tau_p <- windows_ls$mat_weights_tau_p
  joint_window <- windows_ls$joint_window
  ntupq_tau <- windows_ls$ntupq_tau
  ntupq_tau_p <- windows_ls$ntupq_tau_p
  nday <- windows_ls$nday
  day_grid <- windows_ls$day_grid
  
  # browser()
  if(interest_grid){
    # hhat <- calc_hhat_num2_c(nday, ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist)
    hhat <- calc_hhat_num_c6(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist,
                             same_tau = TRUE)
    hhat <- hhat + `diag<-`(t(hhat), 0)
    # bench_base <- bench::mark(calc_hhat_num2_c(nday, ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist))
    # hhat <- bench_base$result[[1]]
    # hhat[,,1]
    # bench_base[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result              memory     time           gc
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>              <list>     <list>         <list>
    # #   1    2.42m    2.42m   0.00690    20.2MB   0.0690     1    10      2.42m <dbl [83 × 83 × 1]> <Rprofmem> <bench_tm [1]> <tibble>
    # 
    # bench_alter <- bench::mark(calc_hhat_num_c(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist))
    # hhat2 <- bench_alter$result[[1]]
    # bench_alter[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result          memory                 time           gc              
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>          <list>                 <list>         <list>          
    # #   1    8.14m    8.14m   0.00205      59KB  0.00614     1     3      8.14m <dbl [83 × 83]> <Rprofmem [2,105 × 3]> <bench_tm [1]> <tibble [1 × 3]>
    # bench_alter2 <- bench::mark(calc_hhat_num_c2(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist))
    # hhat3 <- bench_alter2$result[[1]]
    # bench_alter2[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result          memory               time           gc      
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>          <list>               <list>         <list>  
    # #   1    11.8m    11.8m   0.00141     523KB  0.00566     1     4      11.8m <dbl [83 × 83]> <Rprofmem [606 × 3]> <bench_tm [1]> <tibble>
    # 
    # 
    # bench_alter3 <- bench::mark(calc_hhat_num_c3(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist))
    # hhat4 <- bench_alter3$result[[1]]
    # bench_alter3[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result          memory                 time       gc      
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>          <list>                 <list>     <list>  
    # #   1    4.01m    4.01m   0.00415    1.01MB   0.0125     1     3      4.01m <dbl [83 × 83]> <Rprofmem [1,215 × 3]> <bench_tm> <tibble>
    # 
    # 
    # # 4 NOT CORRECT 
    # bench_alter4 <- bench::mark(calc_hhat_num_c4(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist))
    # hhat5 <- bench_alter4$result[[1]]
    # bench_alter4[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result          memory                 time       gc      
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>          <list>                 <list>     <list>  
    # #   1    2.52m    2.52m   0.00661    3.33MB   0.0198     1     3      2.52m <dbl [83 × 83]> <Rprofmem [1,019 × 3]> <bench_tm> <tibble>
    # 
    # bench_alter5 <- bench::mark(calc_hhat_num_c5(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist))
    # hhat6 <- bench_alter5$result[[1]]
    # bench_alter5[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result          memory             time           gc      
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>          <list>             <list>         <list>  
    # #   1    41.1s    41.1s    0.0243      59KB   0.0729     1     3      41.1s <dbl [83 × 83]> <Rprofmem [4 × 3]> <bench_tm [1]> <tibble>
    # 
    # # fastest
    # bench_alter6 <- bench::mark(calc_hhat_num_c6(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, joint_window, cf_slist, 
    #                                              TRUE))
    # hhat7 <- bench_alter6$result[[1]]
    # hhat7 <- hhat7 + `diag<-`(t(hhat7), 0)
    # bench_alter6[,-1]
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result          memory             time           gc              
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>          <list>             <list>         <list>          
    # #   1    19.2s    19.2s    0.0521      59KB    0.104     1     2      19.2s <dbl [83 × 83]> <Rprofmem [4 × 3]> <bench_tm [1]> <tibble [1 × 3]>
    # all.equal({
    #   x <- hhat7
    #   x[lower.tri(x)] <-  t(hhat7)[lower.tri(t(hhat7))]
    #   x
    # }, hhat6, 0.0001)
    # bench::mark(
    #   hhat7 + `diag<-`(t(hhat7), 0), 
    #   `[<-`(hhat7, temp <- lower.tri(hhat7),t(hhat7)[temp])
    # )
    # # expression                                                  min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc
    # # <bch:expr>                                             <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>
    # #   1 hhat7 + `diag<-`(t(hhat7), 0)                            28.5µs     43µs    11918.     109KB     2.14  5564     1
    # # 2 `[<-`(hhat7, temp <- lower.tri(hhat7), t(hhat7)[temp])   55.9µs   82.1µs     9027.     296KB     0     4512     0
    # 
    # Rcpp::sourceCpp('../ycevo/src/dbar_cpp.cpp', env = current_env())
    
    day_grid <- day_grid[rep(1:nday, each=ntupq_tau_p*ntupq_tau),]
    hhat <- data.frame(hhat_numer = c(hhat), ug = day_grid$ug, rg = day_grid$rg)
  } else {
    hhat <- calc_hhat_num_c6(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, mat_weights_tau, mat_weights_tau_p, mat_weights_qdatetime, cf_slist,
                             same_tau = TRUE)
    hhat <- hhat + `diag<-`(t(hhat), 0)
    # bench_base <- bench::mark(calc_hhat_num2_c(nday, ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, 
    #                                            mat_weights_tau, mat_weights_tau_p, mat_weights_qdatetime, cf_slist))
    # hhat <- bench_base$result[[1]]
    # bench_base[,-1]
    # # # A tibble: 1 × 12
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result            memory             time               gc                  
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>            <list>             <list>             <list>              
    # # 1    319µs    367µs     2612.    2.49KB     2.33  1123     1      430ms <dbl [4 × 4 × 1]> <Rprofmem [1 × 3]> <bench_tm [1,124]> <tibble [1,124 × 3]>
    
    # bench_alter <- bench::mark(calc_hhat_num_c(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, 
    #                                            mat_weights_tau, mat_weights_tau_p, mat_weights_qdatetime, cf_slist))
    # hhat2 <- bench_alter$result[[1]]
    # hhat2
    # bench_alter[,-1]
    # # min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result        memory             time               gc                  
    # # <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>        <list>             <list>             <list>              
    # #   1   71.3µs   82.6µs    11446.    2.49KB     2.14  5356     1      468ms <dbl [4 × 4]> <Rprofmem [1 × 3]> <bench_tm [5,357]> <tibble [5,357 × 3]>
    
    # Rcpp::sourceCpp('../ycevo/src/dbar_cpp.cpp', env = current_env())
    # calc_hhat_num_c(ntupq_tau, ntupq_tau_p, day_idx, tupq_idx_tau, tupq_idx_tau_p, 
    #                 mat_weights_tau, mat_weights_tau_p, mat_weights_qdatetime, cf_slist)
    
    hhat <- data.frame(hhat_numer = c(hhat), ug = rep(xgrid, rep(ntupq_tau_p * ntupq_tau, nday)))
  }
  
  hhat$xg <- rep(tau, nday*ntupq_tau_p)
  hhat$qg <- rep(tau_p, rep(ntupq_tau, ntupq_tau_p))
  
  hhat
}

#' @param hx Numeric vector of values between 0 and 1. Bandwidth parameter determining the size of the window 
#' that corresponds to each time point (\code{xgrid}).
#' See \code{Details}.
#' The selection of bandwidth parameter is crucial in non-parametric estimation.
#' If not sure, please use \code{ycevo} to allow the function choose it for you.
#' @param ht Numeric vector that
#' represents bandwidth parameter determining the size of the window 
#' in the kernel function
#' that corresponds to each time-to-maturities (\code{tau}). 
#' The same unit as \code{tau}.
#' See \code{Details}.
#' The selection of bandwidth parameter is crucial in non-parametric estimation.
#' If not sure, please use \code{ycevo} to allow the function choose it for you.
#' @param rgrid (Optional) Numeric vector of interest rate grids in percentage at which the discount curve is evaluated, e.g. 4.03 means at interest rate of 4.03\%.
#' @param hr (Optional) Numeric vector of bandwidth parameter in percentage determining the size of the window
#' in the kernel function
#' that corresponds to each interest rate grid (\code{rgrid}).
#' @param interest (Optional) Numeric vector of daily short term interest rates. 
#' The length is the same as the number of quotation dates included in the data, 
#' i.e. one interest rate per day.
#' @param cfp_slist (Internal) Experienced users only. A list of matrices, generated by the internal function \code{get_cfp_slist}.
#' 
#' @return Data frame of the yield and discount rate at each combination of the provided grids.
#' \describe{
#'   \item{discount}{Estimated discount rate}
#'   \item{xgrid}{Same as input \code{xgrid}}
#'   \item{tau}{Same as input \code{tau}}
#'   \item{yield}{Estimated yield}
#' }
#' 
#' @author Nathaniel Tomasetti, Bonsoo Koo, and Yangzhuoran Fin Yang
#' @describeIn ycevo Experienced users only. 
#' Yield estimation with interest rate and manually selected bandwidth parameters.
#' @export
estimate_yield <- function(data, xgrid, hx, tau, ht, 
                           rgrid = NULL, hr = NULL, 
                           interest = NULL, loess = TRUE, 
                           cfp_slist = NULL){
  units <- 365
  
  tau_p <- tau
  htp <- ht
  if(!is.null(rgrid) & !is.null(hr) & !is.null(interest)){
    interest_grid <- TRUE
  } else {
    interest_grid <- FALSE
  }
  
  # Check inputs
  stopifnot(is.vector(xgrid))
  stopifnot(is.numeric(xgrid))
  stopifnot(is.vector(hx))
  stopifnot(is.numeric(hx))
  stopifnot(is.data.frame(data))
  stopifnot(is.vector(tau))
  stopifnot(is.numeric(tau))
  stopifnot(is.vector(ht))
  stopifnot(is.numeric(ht))
  stopifnot(length(xgrid) == length(hx))
  stopifnot(length(tau) == length(ht))
  stopifnot(all(c('qdate', 'crspid', 'mid.price', 'accint', 'pdint', 'tupq') %in% colnames(data)))
  
  
  if(is.null(cfp_slist)){
    cfp_slist <- get_cfp_slist(data)
  }
  cf_slist <- cfp_slist$cf_slist
  price_slist <- cfp_slist$price_slist
  
  windows_ls <- prep_windows(data = data, 
                             xgrid = xgrid, 
                             hx = hx, 
                             rgrid = rgrid, 
                             hr = hr, 
                             tau = tau, 
                             ht = ht, 
                             tau_p = tau_p, 
                             htp = htp, 
                             interest = interest, 
                             units = units, 
                             interest_grid = interest_grid)
  # Estimate dbar & the numerator of the h-hat matrix
  dbar <- calc_dbar(data = data,
                    xgrid = xgrid,
                    tau = tau,
                    price_slist = price_slist,
                    cf_slist = cf_slist,
                    interest_grid = interest_grid, 
                    windows_ls = windows_ls)
  
  hhat_num <- calc_hhat_num(data = data,
                            xgrid = xgrid,
                            tau = tau,
                            tau_p = tau_p,
                            cf_slist = cf_slist,
                            interest_grid = interest_grid, 
                            windows_ls = windows_ls)
  
  if(any(dbar$dbar_denom == 0)) {
    problem_tau <- filter(dbar, .data$dbar_denom == 0)$xg 
    warning("tau values at ", paste(problem_tau, collapse = ", "), " does not have enough obs to estimate yield")
    
    output <- estimate_yield(
      data = data,
      xgrid = xgrid,
      hx = hx,
      tau = tau[!tau %in% problem_tau],
      ht = ht[!tau %in% problem_tau], 
      loess = FALSE)
    return(output)
  }
  
  
  
  # The denominator of h-hat entries are estimated as part of dbar
  if(interest_grid){
    
    hhat <- dplyr::mutate(
      dplyr::right_join(
        dplyr::select(dbar, !!sym('ug'), !!sym('xg'), !!sym('rg'), !!sym('dbar_denom')),
        hhat_num,
        by = c('ug' = 'ug', 'xg' = 'xg', 'rg' = 'rg')
      ),
      hhat = !!sym('hhat_numer') / !!sym('dbar_denom')
    )
    
    day_grid <- unique(hhat[c('ug', 'rg')])
  } else {
    hhat <- dplyr::mutate(
      dplyr::right_join(
        dplyr::select(dbar, !!sym('ug'), !!sym('xg'), !!sym('dbar_denom')),
        hhat_num,
        by = c('ug' = 'ug', 'xg' = 'xg')
      ),
      hhat =!!sym('hhat_numer') / !!sym('dbar_denom')
    )
    day_grid <- data.frame(ug = unique(hhat$ug), rg = 0)
    hhat$rg <- 0
    dbar$rg <- 0
  }
  
  # Create the dataframe that the function returns
  dhat <- data.frame()
  for(i in 1:nrow(day_grid)){
    
    # Create the dbar vector and h-hat matrix for this value of ugrid
    db <- dplyr::mutate(
      dplyr::filter(dbar, !!sym('ug') == day_grid$ug[i], !!sym('rg') == day_grid$rg[i]),
      dbar = !!sym('dbar_numer') / !!sym('dbar_denom')
    )$dbar
    
    hh <- matrix(dplyr::filter(hhat, !!sym('ug') == day_grid$ug[i], !!sym('rg') == day_grid$rg[i])$hhat,
                 nrow = length(db))
    if(any(is.na(db))){
      na <- which(is.na(db))
      if(is.vector(tau) & is.vector(tau_p)){
        xgr <- tau[-na]
        qgr <- tau_p[tau_p <= max(xgr)]
      } else if(nrow(tau) == 1 & nrow(tau_p) == 1){
        xgr <- tau[-na]
        qgr <- tau_p[tau_p <= max(xgr)]
      } else {
        xgr <- tau[i,-na]
        qgr <- tau_p[i, tau_p[tau_p <= max(xgr)]]
      }
      db <- db[-na]
      hh <- hh[1:length(xgr), 1:length(qgr)]
    } else {
      if(is.vector(tau) & is.vector(tau_p)){
        xgr <- tau
        qgr <- tau_p
      } else if(nrow(tau) == 1 & nrow(tau_p) == 1){
        xgr <- tau
        qgr <- tau_p
      } else {
        xgr <- tau[i, ]
        qgr <- tau_p[i, ]
      }
    }
    
    
    # Extract the xgrid and qgrid for this value of u as xgr and qgr. 
    # The dimensions of these objects are tested earlier in the code.
    
    # Create a matrix of interpolation weights
    interpol_weights <- matrix(0, length(xgr), length(qgr))
    
    # Iterate over the values of qgrid
    for(j in 1:length(qgr)){
      # If qgrid is contained in xgrid then the weight will be one
      if(any(xgr == qgr[j])){
        interpol_weights[which(xgr == qgr[j]), j] <- 1
      } else {
        # Otherwise find the xgrid immediately above and below this xgrid
        lower <- max(which(xgr < qgr[j]))
        upper <- min(which(xgr > qgr[j]))
        # Error if qgrid is lower than the first xgrid, or greater than the last xgrid
        if(upper == 1 | lower == length(xgr)){
          stop('tau_p entries must lie inside tau')
        }
        # Find interpolation weights as ratio between the two xgrid values lying above and below this qgrid
        dist <- xgr[upper] - xgr[lower]
        interpol_weights[lower, j] <- (qgr[j] - xgr[lower]) / dist
        interpol_weights[upper, j] <- (xgr[upper] - qgr[j]) / dist
      }
    }
    
    # Construct the length(q) x length(x) matrix of the interpolated hhat
    hh_interpol <- matrix(0, length(xgr), length(xgr))
    for(j in 1:length(xgr)){
      hh_interpol[,j] <- colSums(t(hh) * interpol_weights[j,])
    }
    
    # transpose?
    X <- diag(1, length(xgr)) + t(hh_interpol)
    dh <- solve(X) %*% db
    if(interest_grid){
      dhat <- rbind(dhat, data.frame(discount = dh, ug = day_grid$ug[i], rgrid = day_grid$rg[i], qg = xgr))
    } else {
      dhat <- rbind(dhat, data.frame(discount = dh, ug = day_grid$ug[i], qg = xgr))
    }
    
  }
  # loess smoothing
  loess_model <- lapply(
    unique(dhat$ug), 
    function(ugg) stats::loess(discount~qg, 
                               data = filter(dhat, .data$ug == ugg), 
                               control = loess.control(surface = "direct")))
  if(loess){
    dhat$discount <- do.call(base::c, lapply(loess_model, stats::predict))
  }
  dhat$yield <- -log(dhat$discount) / dhat$qg
  dhat <- dplyr::rename(dhat,
                        xgrid = "ug",
                        tau = "qg"
  )
  attr(dhat, "loess") <- loess_model
  return(dhat)
}
