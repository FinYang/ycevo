#' A component of the \code{estimate_yield} function that calculates \eqn{dbar}
#' 
#' Internal function that estimates the discount function without taking into account
#' cross products of coupon payments. Not to be used independently. Exported for documentation purpose.
#' 
#' @param data A data frame; bond data to estimate discount curve from.
#' @param ugrid A length T numeric vector; the times at which the discount curve will be estimated.
#' @param hu A length T numeric vector, bandwidth parameter determining the size of the window
#' that corresponds to each time at which the discount curve is estimated,
#' @param rgrid (Optional) A length K numeric vector of interest rate grid values
#' @param hr (Optional) A length K numeric vector of interest rate grid bandwidths
#' @param xgrid A length m numeric vector, or either a 1 x x or T x x numeric matrix. If a T x x matrix, each row represents the time-to-maturity grid
#' that each time-to-maturity in the discount function is compared against. Otherwise the same time-to-maturity grid is repeated for each of the T ugrid values
#' @param hx An numeric vector of length T, or if xgrid is a matrix, a numeric matrix of the same dimensions as xgrid.
#' A vector hx for a T x m matrix xgrid repeats values for each row of qgrid.
#' bandwidth parameter determining the size of the window that corresponds to each time-to-maturity.
#' @param price_slist (Optional) A list of matrices, generated by calc_price_slist.
#' @param cf_slist (Optional) A list of matrices, generated by calc_cf_slist.
#' @param interest (Optional) A vector of daily short term interest rates
#' @param units (Optional) number of tupq per xgrid (e.g. 365 for daily data with annual grid values). Defaults to 365
#' 
#' @return Data frame with the follwing variables
#' 
#' \describe{
#'   \item{ug}{Same as input \code{ugrid}}
#'   \item{dbar_numer}{Numerator in dbar. See \code{Source}}
#'   \item{dbar_denom}{Denominator in dbar. See \code{Source}}
#'   \item{xg}{Same as input \code{xgrid}}
#' }
#' 
#' @source Koo, B., La Vecchia, D., & Linton, O. B. (2019). Estimation of a Nonparametric model for Bond Prices from Cross-section and Time series Information. Available at SSRN3341344.
#' @author Nathaniel Tomasetti
#' @export
calc_dbar <- function(data, ugrid, hu, rgrid, hr, xgrid, hx, price_slist, cf_slist, interest, units = 365) {
  if (missing(cf_slist)){
    cf_slist <- calc_cf_slist(data)
  }

  if (missing(price_slist)) {
    price_slist <- calc_price_slist(data)
  }

  if(!missing(rgrid) & !missing(hr) & !missing(interest)){
    interest_grid <- TRUE
  } else {
    interest_grid <- FALSE
  }


  day_idx <- calc_day_idx(data, ugrid, hu)
  uu_window <- calc_uu_window(data,ugrid,hu)
  nday <- length(ugrid)

  if(interest_grid){
    r_window <- calc_r_window(interest, rgrid, hr)
    day_grid <- expand.grid(ug = ugrid, rg = rgrid)
    nday <- nrow(day_grid)
    joint_window <- matrix(0, nrow(uu_window), nday)
    for(j in seq_along(rgrid)){
      for(i in seq_along(ugrid)){
        joint_window[, (j-1)*length(ugrid) + i] <- uu_window[,i] * r_window[,j]
      }
    }
    apply(joint_window, 2, function(y) {
      if(all(y == 0)){
       day_idx <- c(0, 0)
      } else {
        window_idx <- which(y != 0)
        day_idx <- c(window_idx[1], window_idx[length(window_idx)])
      }
      day_idx
    }) %>% t() -> day_idx
    obs <- which(day_idx[,1] != 0)
    day_grid <- day_grid[obs, ]
    joint_window <- joint_window[,obs]
    day_idx <- day_idx[obs, ]
    nday <- length(obs)
    if(nday == 1){
      joint_window <- matrix(joint_window, ncol = 1)
      day_idx <- matrix(day_idx, nrow = 1)
    }

  }

  if(is.vector(xgrid)){
    tupq_idx <- calc_tupq_idx(data, xgrid, hx, units)
    ux_window <- calc_ux_window(data, xgrid, hx, units)
    ntupq <- length(xgrid)
  } else if(nrow(xgrid) == 1) {
    tupq_idx <- calc_tupq_idx(data, xgrid, hx, units)
    ux_window <- calc_ux_window(data, xgrid, hx, units)
    ntupq <- length(xgrid)
  } else {
    tupq_idx <- NULL
    ux_window <- NULL
    for(i in 1:nrow(xgrid)){
      if(is.vector(hx)){
        tupq_idx <- cbind(tupq_idx, calc_tupq_idx(data, xgrid[i,], hx, units))
        ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i,], hx, units))
      } else if(nrow(hx) == 1){
        tupq_idx <- cbind(tupq_idx, calc_tupq_idx(data, xgrid[i,], hx, units))
        ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i,], hx, units))
      } else if(nrow(hx) == nrow(xgrid)){
        tupq_idx <- cbind(tupq_idx, calc_tupq_idx(data, xgrid[i,], hx[i, ], units))
        ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i,], hx[i, ], units))
      } else {
        stop('the dimension of hx must match the dimension of xgrid')
      }
    }
    ntupq <- ncol(xgrid)
  }
  
  if(interest_grid){
    dbar <- calc_dbar_c(nday, ntupq, day_idx, tupq_idx, ux_window, joint_window, price_slist, cf_slist)
    day_grid <- day_grid[rep(1:nday, each=ntupq),]
    dbar <- data.frame(ug = day_grid$ug, rg = day_grid$rg, dbar_numer = dbar[,1], dbar_denom = dbar[,2])
  } else {
    dbar <- calc_dbar_c(nday, ntupq, day_idx, tupq_idx, ux_window, uu_window, price_slist, cf_slist)
    dbar <- data.frame(ug = rep(ugrid, rep(ntupq, nday)), dbar_numer = dbar[,1], dbar_denom = dbar[,2])
  }
  if(is.vector(xgrid)){
    dbar$xg = rep(xgrid, nday)
  } else if(nrow(xgrid) == 1) {
    dbar$xg = rep(xgrid, nday)
  } else {
    dbar$xg = c(t(xgrid))
  }
  dbar
}

#' A component of the \code{estimate_yield} function that calculates \eqn{hhat}
#' 
#' Internal function that calculates coupon payment cross products. 
#' Not to be used independently. Exported for documentation purpose.
#' 
#' @param data A data frame; bond data to estimate discount curve from.
#' @param ugrid A length T numeric vector; the times at which the discount curve will be estimated.
#' @param hu A length T numeric vector, bandwidth parameter determining the size of the window
#' that corresponds to each time at which the discount curve is estimated,
#' @param rgrid (Optional) A length K numeric vector of interest rate grid values
#' @param hr (Optional) A length K numeric vector of interest rate grid bandwidths
#' @param xgrid A length m numeric vector, or either a 1 x m or T x m numeric matrix. If a T x m matrix, each row represents the time-to-maturity grid
#' for the discount function at the corresponding time. Otherwise the same time-to-maturity grid is repeated for each of the T ugrid values
#' @param hx An numeric vector of length T, or if xgrid is a matrix, a numeric matrix of the same dimensions as xgrid.
#' A vector hx for a T x m matrix qgrid repeats values for each row of xgrid.
#' bandwidth parameter determining the size of the window that corresponds to each time-to-maturity.
#' @param qgrid (Optional), A length m numeric vector, or either a 1 x m or T x m numeric matrix, matching xgrid input with m allowed to be different to M.
#' If a T x m matrix, each row represents the time-to-maturity grid that each time-to-maturity in the discount function is compared against.
#' Otherwise the same time-to-maturity grid is repeated for each of the T ugrid values.
#' If m = M, and each entry of qgrid is identical to xgrid, estimation is performed without interpolaton of the h-hat matrix.
#' If the entries are not identical each entry of each row of qgrid must be within the range from the smallest to largest value of the corresponding row of xgrid,
#' and linear interpolation of the h-hat matrix is performed.
#' If omitted, qgrid is set equal to xgrid.
#' @param hq (Optional) An numeric vector of length T, or if qgrid is a matrix, a numeric matrix of the same dimensions as qgrid.
#' A vector hq for a T x M matrix qgrid repeats values for each row of qgrid.
#' bandwidth parameter determining the size of the window that corresponds to each time-to-maturity.
#' If omitted, hq is set equal to hx
#' @param cf_slist (Optional) A list of matrices, generated by calc_cf_slist.
#' @param interest (Optional) A vector of daily short term interest rates
#' @param units (Optional) number of tupq per xgrid (e.g. 365 for daily data with annual grid values). Defaults to 365
#' 
#' @return Data frame with the follwing variables
#' 
#' \describe{
#'   \item{hhat_numer}{Numerator in H hat. See \code{Source}}
#'   \item{ug}{Same as input \code{ugrid}}
#'   \item{xg}{Same as input \code{xgrid}}
#'   \item{qg}{Same as input \code{qgrid}}
#' }
#' 
#' @author Nathaniel Tomasetti
#' @source Koo, B., La Vecchia, D., & Linton, O. B. (2019). Estimation of a Nonparametric model for Bond Prices from Cross-section and Time series Information. Available at SSRN3341344.
#' @export
calc_hhat_num <- function(data, ugrid, hu, rgrid, hr, xgrid, hx, qgrid, hq, cf_slist, interest, units = 465) {
  if (missing(cf_slist)){
    cf_slist <- calc_cf_slist(data)
  }
  if (missing(qgrid)){
    qgrid <- xgrid
  }
  if (missing(hq)){
    hq <- hx
  }
  if(!missing(rgrid) & !missing(hr) & !missing(interest)){
    interest_grid <- TRUE
  } else {
    interest_grid <- FALSE
  }



  # windows etc
  day_idx <- calc_day_idx(data, ugrid, hu)
  uu_window <- calc_uu_window(data,ugrid,hu)
  nday <- length(ugrid)
  if(interest_grid){
    r_window <- calc_r_window(interest, rgrid, hr)
    day_grid <- expand.grid(ug = ugrid, rg = rgrid)
    nday <- nrow(day_grid)
    joint_window <- matrix(0, nrow(uu_window), nday)
    for(j in seq_along(rgrid)){
      for(i in seq_along(ugrid)){
        joint_window[, (j-1)*length(ugrid) + i] <- uu_window[,i] * r_window[,j]
      }
    }
    apply(joint_window, 2, function(y) {
      if(all(y == 0)){
        day_idx <- c(0, 0)
      } else {
        window_idx <- which(y != 0)
        day_idx <- c(window_idx[1], window_idx[length(window_idx)])
      }
      day_idx
    }) %>% t() -> day_idx
    obs <- which(day_idx[,1] != 0)
    day_grid <- day_grid[obs, ]
    joint_window <- joint_window[,obs]
    day_idx <- day_idx[obs, ]
    nday <- length(obs)
    if(nday == 1){
      joint_window <- matrix(joint_window, ncol = 1)
      day_idx <- matrix(day_idx, nrow = 1)
    }

  }


  if(is.vector(xgrid)){
    tupq_idx_x <- calc_tupq_idx(data, xgrid, hx, units)
    ux_window <- calc_ux_window(data, xgrid, hx, units)
    ntupq_x <- length(xgrid)
  } else if(nrow(xgrid) == 1){
    tupq_idx_x <- calc_tupq_idx(data, xgrid, hx, units)
    ux_window <- calc_ux_window(data, xgrid, hx, units)
    ntupq_x <- length(xgrid)
  } else {
    tupq_idx_x <- NULL
    ux_window <- NULL
    ntupq_x <- ncol(xgrid)
    for(i in 1:nrow(xgrid)){
      for(i in 1:nrow(xgrid)){
        if(is.vector(hx)){
          tupq_idx_x <- cbind(tupq_idx_x, calc_tupq_idx(data, xgrid[i,], hx, units))
          ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i, ], hx, units))
        } else if(nrow(hx) == 1){
          tupq_idx_x <- cbind(tupq_idx_x, calc_tupq_idx(data, xgrid[i,], hx, units))
          ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i, ], hx, units))
        } else if(nrow(hx) == nrow(xgrid)){
          tupq_idx_x <- cbind(tupq_idx_x, calc_tupq_idx(data, xgrid[i,], hx[i, ], units))
          ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i, ], hx[i, ], units))
        } else {
          stop('the dimension of hx must match the dimension of xgrid')
        }
      }
    }
  }

  if(is.vector(qgrid)){
    tupq_idx_q <- calc_tupq_idx(data, qgrid, hq, units)
    uq_window <- calc_ux_window(data, qgrid, hq, units)
    ntupq_q <- length(qgrid)
  } else if(nrow(qgrid) == 1){
    tupq_idx_q <- calc_tupq_idx(data, qgrid, hq, units)
    uq_window <- calc_ux_window(data, qgrid, hq, units)
    ntupq_q <- length(qgrid)
  } else {
    tupq_idx_q <- NULL
    uq_window <- NULL
    ntupq_q <- ncol(qgrid)
    for(i in 1:nrow(qgrid)){
      for(i in 1:nrow(qgrid)){
        if(is.vector(hq)){
          tupq_idx_q <- cbind(tupq_idx_q, calc_tupq_idx(data, qgrid[i,], hq, units))
          uq_window <- cbind(uq_window, calc_ux_window(data, qgrid[i, ], hq, units))
        } else if(nrow(hq) == 1){
          tupq_idx_q <- cbind(tupq_idx_q, calc_tupq_idx(data, qgrid[i,], hq, units))
          uq_window <- cbind(uq_window, calc_ux_window(data, qgrid[i, ], hq, units))
        } else if(nrow(hq) == nrow(qgrid)){
          tupq_idx_q <- cbind(tupq_idx_q, calc_tupq_idx(data, qgrid[i,], hq[i, ], units))
          uq_window <- cbind(uq_window, calc_ux_window(data, qgrid[i, ], hq[i, ], units))
        } else {
          stop('the dimension of hq must match the dimension of qgrid')
        }
      }
    }
  }

  if(interest_grid){
    hhat <- calc_hhat_num2_c(nday, ntupq_x, ntupq_q, day_idx, tupq_idx_x, tupq_idx_q, ux_window, uq_window, joint_window, cf_slist)
    day_grid <- day_grid[rep(1:nday, each=ntupq_q*ntupq_x),]
    hhat <- data.frame(hhat_numer = c(hhat), ug = day_grid$ug, rg = day_grid$rg)
  } else {
    hhat <- calc_hhat_num2_c(nday, ntupq_x, ntupq_q, day_idx, tupq_idx_x, tupq_idx_q, ux_window, uq_window, uu_window, cf_slist)
    hhat <- data.frame(hhat_numer = c(hhat), ug = rep(ugrid, rep(ntupq_q * ntupq_x, nday)))
  }

   if(is.vector(xgrid)){
    hhat$xg = rep(xgrid, nday*ntupq_q)
  } else if(nrow(xgrid) == 1){
    hhat$xg = rep(xgrid, nday*ntupq_q)
  } else {
    x_temp = NULL
    for(i in 1:nday){
      x_temp = c(x_temp, rep(xgrid[i,], ntupq_q))
    }
    hhat$xg = x_temp
  }

  if(is.vector(qgrid)){
    hhat$qg = rep(qgrid, rep(ntupq_x, ntupq_q))
  } else if(nrow(qgrid) == 1){
    hhat$qg = rep(qgrid, rep(ntupq_x, ntupq_q))
  } else {
    q_temp = NULL
    for(i in 1:nday){
      q_temp = c(q_temp, rep(qgrid[i,], rep(ntupq_x, ntupq_q)))
    }
    hhat$qg = q_temp
  }

  hhat
}

#' Estimate yield function
#' 
#' Estimation of discount function and transformation to yield at given dates, time to maturities, and interest rates.
#' 
#' @param data A data frame; bond data to estimate discount curve from.
#' @param ugrid A length T numeric vector; the times at which the discount curve will be estimated.
#' @param hu A length T numeric vector, bandwidth parameter determining the size of the window
#' that corresponds to each time at which the discount curve is estimated,
#' @param rgrid (Optional) A length K numeric vector of interest rate grid values
#' @param hr (Optional) A length K numeric vector of interest rate grid bandwidths
#' @param qgrid A length m numeric vector, or either a 1 x m or T x m numeric matrix.
#' Represents the qgrid of T time-to-maturities values to estimate the yield for.
#' If this is a T x m matrix, each row represents the grid for a given ugrid value.
#' If this is a vector or T x 1 matrix, entries represents the qgrid, which will be repeated for each ugrid.
#' @param hq A numeric object in the same format as qgrid containing the kernel bandwidth for each qgrid value.
#' @param xgrid (Optional) A length m numeric vector, or either a 1 x m or T x m numeric matrix.
#' If a T x m matrix, each row represents the time-to-maturity grid for a given ugrid value, otherwise the same xgrid values are repeated for each ugrid value.
#' If m = M, and each entry of qgrid is identical to xgrid, estimation is performed without interpolaton of the h-hat matrix.
#' If the entries are not identical, the qgrid values must not lie outside the range given by the smallest to largest xgrid value
#' Linear interpolation of the h-hat matrix is then performed.
#' If omitted, xgrid is set equal to qgrid.
#' @param hx A numeric object in the same format as xgrid containing the kernel bandwidth for each xgrid value.
#' If xgrid is omitted, hx is set to equal hq.
#' @param price_slist (Optional) A list of matrices, generated by calc_price_slist.
#' @param cf_slist (Optional) A list of matrices, generated by calc_cf_slist.
#' @param interest (Optional) A vector of daily short term interest rates
#' @param units (Optional) number of tupq per xgrid (e.g. 365 for daily data with annual grid values). Defaults to 365
#' @param loess (Optional) Logical. Whether the output estimated discount and yield are to be smoothed using locally estimated scatterplot smoothing (LOESS)
#' @author Nathaniel Tomasetti
#' @examples
#' \donttest{
#' ugrid <- 0.207171315
#' hu <- 0.2
#' max_tumat <- max(USbonds$tumat)
#' qgrid <- c(seq(30, 6 * 30, 30),  # Monthly up to six months
#'            seq(240, 2 * 365, 60),  # Two months up to two years
#'            seq(720 + 90, 6 * 365, 90),  # Three months up to six years
#'            seq(2160 + 120, 20 * 365, 120),  # Four months up to 20 years
#'            #               seq(20 * 365 + 182, 30 * 365, 182)) / 365 # Six months up to 30 years
#'            seq(20 * 365 + 182, 30.6 * 365, 182)) / 365
#' # Cut qgrid so that there is one value greater than the maximum to maturity
#' qgrid <- qgrid[1:min(which(qgrid >= max_tumat / 365))]
#' 
#' laggap <- qgrid - dplyr::lag(qgrid)
#' leadgap <- dplyr::lead(qgrid) - qgrid
#' hq <- vapply(1:length(qgrid), function(x) max(laggap[x], leadgap[x], na.rm = TRUE), runif(1))
#' grids <- create_xgrid_hx(USbonds, ugrid, hu, qgrid, hq, 5)
#' 
#' price <- calc_price_slist(USbonds)
#' cf <- calc_cf_slist(USbonds)
#' dhat <- estimate_yield(data = USbonds, ugrid = ugrid, hu = hu, xgrid = grids$xgrid,
#'                hx=grids$hx, qgrid = qgrid,hq= hq, price_slist=price, cf_slist = cf)
#' }
#' @export
#' @details Provides a data.frame of the yield and discount rate at each combination of the provided grids. Estimation follows (CITATION), with five major steps:
#' 1. Estimation of dbar, a component of the discount rate that ignores cross products.
#' 2. Estimation of hhat, the cross product component of the discount rate, using both qgrid and xgrid.
#' 3. Interpolation of hhat when the provided xgrid values are not equal to those found in qgrid.
#' 4. Solving a linear equation to result in dhat, the discount rate.
#' 5. Transformation of the discount rate into a yield.
#' @return Data frame of the yield and discount rate at each combination of the provided grids.
#' \describe{
#'   \item{discount}{Estimated discount rate}
#'   \item{ug}{Same as input \code{ugrid}}
#'   \item{qg}{Same as input \code{qgrid}}
#'   \item{yield}{Estimated yield}
#' }
#' 
estimate_yield <- function(data, ugrid, hu, rgrid, hr, xgrid, hx, qgrid, hq, price_slist, cf_slist, interest, units = 365, loess = TRUE){
  if (missing(xgrid)){
    xgrid <- qgrid
  }
  if(missing(hx)){
    hx <- hq
  }
  if(!missing(rgrid) & !missing(hr) & !missing(interest)){
    interest_grid <- TRUE
  } else {
    interest_grid <- FALSE
  }
  
  # Check inputs
  if(!is.vector(ugrid)){
    stop('ugrid must be a vector')
  }
  if(!is.vector(hu)){
    stop('hu must be a vector')
  }
  if(!is.data.frame(data)){
    stop('data must be a dataframe')
  }
  if(!all(c('qdate', 'crspid', 'tumat', 'mid.price', 'accint', 'pdint', 'tupq') %in% colnames(data))){
    stop('data must contain columns qdate, crspid, tumat, mid.price, accint, pdint, and tupq')
  }
  if(!is.matrix(xgrid) & !is.vector(xgrid)){
    stop('xgrid must be a vector or a matrix')
  }
  if(!is.matrix(qgrid) & !is.vector(qgrid)){
    stop('qgrid must be a vector or a matrix')
  }
  if(!is.matrix(hq) & !is.vector(hq)){
    stop('hq must be a vector or a matrix')
  }
  if(!is.numeric(ugrid)){
    stop('ugrid must be numeric')
  }
  if(!is.numeric(hu)){
    stop('hu must be numeric')
  }
  if(!is.numeric(xgrid)){
    stop('xgrid must be numeric')
  }
  if(!is.numeric(qgrid)){
    stop('qgrid must be numeric')
  }
  if(!is.numeric(hq)){
    stop('hq must be numeric')
  }
  # Check if hq matches ugrid
  if(length(ugrid) != length(hu)){
    stop('ugrid and hu must have the same length')
  }
  # Check if xgrid matches qgrid
  if((is.matrix(xgrid) & is.matrix(qgrid)) | is.vector(xgrid) & is.vector(qgrid)){
    if(is.matrix(xgrid)){
      if(nrow(xgrid) != nrow(qgrid)){
        stop('xgrid and qgrid have incompatible sizes, both matrices contain the same number of rows')
      }
      if(nrow(xgrid) != 1 | nrow(xgrid) != length(ugrid)){
        stop('xgrid and qgrid must have one row, or both have a number of rows equal to the length of ugrid')
      }
    }
  } else {
    stop('xgrid and qgrid have incompatible sizes, both objects must have the same class and, if a matrix, contain the same number of rows.')
  }
  # Check if hq matches qgrid
  if(is.vector(qgrid)){
    if(is.vector(hq)){
      if(length(hq) != length(qgrid)){
        stop('hq and qgrid must have the same length')
      }
    } else {
      stop('hq must be a vector of qgrid is a vector')
    }
  }
  if(is.matrix(qgrid)){
    if(is.vector(hq)){
      if(length(hq) != ncol(qgrid)){
        stop('a vector hq must have a length equal to the number of columns of qgrid')
      }
    } else {
      if(ncol(hq) != ncol(qgrid) | nrow(hq) != nrow(qgrid)){
        stop('a matrix hq must have the same dimensions as qgrid')
      }
    }
  }
  
  # Check if hx matches xgrid
  if(is.vector(xgrid)){
    if(is.vector(hx)){
      if(length(hx) != length(xgrid)){
        stop('hx and xgrid must have the same length')
      }
    } else {
      stop('hx must be a vector of xgrid is a vector')
    }
  }
  if(is.matrix(xgrid)){
    if(is.vector(hx)){
      if(length(hx) != ncol(xgrid)){
        stop('a vector hx must have a length equal to the number of columns of xgrid')
      }
    } else {
      if(ncol(hx) != ncol(xgrid) | nrow(hx) != nrow(xgrid)){
        stop('a matrix hx must have the same dimensions as xgrid')
      }
    }
  }
  
  if(missing(cf_slist)){
    cf_slist <- calc_cf_slist(data)
  }
  
  if(missing(price_slist)) {
    price_slist <- calc_price_slist(data)
  }
  # Estimate dbar & the numerator of the h-hat matrix
  if(interest_grid){
    dbar <- calc_dbar(data = data,
                      ugrid = ugrid,
                      hu = hu,
                      rgrid = rgrid,
                      hr = hr,
                      xgrid = xgrid,
                      hx = hx,
                      price_slist = price_slist,
                      cf_slist = cf_slist,
                      interest = interest,
                      units = units)
    
    hhat_num <- calc_hhat_num(data = data,
                              ugrid = ugrid,
                              hu = hu,
                              rgrid = rgrid,
                              hr = hr,
                              xgrid = xgrid,
                              hx = hx,
                              qgrid = qgrid,
                              hq = hq,
                              cf_slist = cf_slist,
                              interest = interest,
                              units = units)
  } else {
    dbar <- calc_dbar(data = data,
                      ugrid = ugrid,
                      hu = hu,
                      xgrid = xgrid,
                      hx = hx,
                      price_slist = price_slist,
                      cf_slist = cf_slist,
                      units = units)
    
    hhat_num <- calc_hhat_num(data = data,
                              ugrid = ugrid,
                              hu = hu,
                              xgrid = xgrid,
                              hx = hx,
                              qgrid = qgrid,
                              hq = hq,
                              cf_slist = cf_slist,
                              units = units)
  }
  
  
  # The denominator of h-hat entries are estimated as part of dbar
  if(interest_grid){
    
    hhat <- dplyr::mutate(
      dplyr::right_join(
        dplyr::select(dbar, !!sym('ug'), !!sym('xg'), !!sym('rg'), !!sym('dbar_denom')),
        hhat_num,
        by = c('ug' = 'ug', 'xg' = 'xg', 'rg' = 'rg')
      ),
      hhat = !!sym('hhat_numer') / !!sym('dbar_denom')
    )
    
    day_grid <- unique(hhat[c('ug', 'rg')])
  } else {
    hhat <- dplyr::mutate(
      dplyr::right_join(
        dplyr::select(dbar, !!sym('ug'), !!sym('xg'), !!sym('dbar_denom')),
        hhat_num,
        by = c('ug' = 'ug', 'xg' = 'xg')
      ),
      hhat =!!sym('hhat_numer') / !!sym('dbar_denom')
    )
    day_grid <- data.frame(ug = unique(hhat$ug), rg = 0)
    hhat$rg <- 0
    dbar$rg <- 0
  }
  
  
  # Create the dataframe that the function returns
  dhat <- data.frame()
  for(i in 1:nrow(day_grid)){
    
    # Create the dbar vector and h-hat matrix for this value of ugrid
    db <- dplyr::mutate(
      dplyr::filter(dbar, !!sym('ug') == day_grid$ug[i], !!sym('rg') == day_grid$rg[i]),
      dbar = !!sym('dbar_numer') / !!sym('dbar_denom')
    )$dbar
    
    hh <- matrix(dplyr::filter(hhat, !!sym('ug') == day_grid$ug[i], !!sym('rg') == day_grid$rg[i])$hhat,
                 nrow = length(db))
    if(any(is.na(db))){
      na <- which(is.na(db))
      if(is.vector(xgrid) & is.vector(qgrid)){
        xgr <- xgrid[-na]
        qgr <- qgrid[qgrid <= max(xgr)]
      } else if(nrow(xgrid) == 1 & nrow(qgrid) == 1){
        xgr <- xgrid[-na]
        qgr <- qgrid[qgrid <= max(xgr)]
      } else {
        xgr <- xgrid[i,-na]
        qgr <- qgrid[i, qgrid[qgrid <= max(xgr)]]
      }
      db <- db[-na]
      hh <- hh[1:length(xgr), 1:length(qgr)]
    } else {
      if(is.vector(xgrid) & is.vector(qgrid)){
        xgr <- xgrid
        qgr <- qgrid
      } else if(nrow(xgrid) == 1 & nrow(qgrid) == 1){
        xgr <- xgrid
        qgr <- qgrid
      } else {
        xgr <- xgrid[i, ]
        qgr <- qgrid[i, ]
      }
    }
    
    
    # Extract the xgrid and qgrid for this value of u as xgr and qgr. 
    # The dimensions of these objects are tested earlier in the code.
    
    # Create a matrix of interpolation weights
    interpol_weights <- matrix(0, length(xgr), length(qgr))
    
    # Iterate over the values of qgrid
    for(j in 1:length(qgr)){
      # If qgrid is contained in xgrid then the weight will be one
      if(any(xgr == qgr[j])){
        interpol_weights[which(xgr == qgr[j]), j] <- 1
      } else {
        # Otherwise find the xgrid immediately above and below this xgrid
        lower <- max(which(xgr < qgr[j]))
        upper <- min(which(xgr > qgr[j]))
        # Error if qgrid is lower than the first xgrid, or greater than the last xgrid
        if(upper == 1 | lower == length(xgr)){
          stop('qgrid entries must lie inside xgrid')
        }
        # Find interpolation weights as ratio between the two xgrid values lying above and below this qgrid
        dist <- xgr[upper] - xgr[lower]
        interpol_weights[lower, j] <- (qgr[j] - xgr[lower]) / dist
        interpol_weights[upper, j] <- (xgr[upper] - qgr[j]) / dist
      }
    }
    
    # Construct the length(q) x length(x) matrix of the interpolated hhat
    hh_interpol <- matrix(0, length(xgr), length(xgr))
    for(j in 1:length(xgr)){
      hh_interpol[,j] <- colSums(t(hh) * interpol_weights[j,])
    }
    
    X <- diag(1, length(xgr)) + hh_interpol
    dh <- solve(X) %*% db
    if(interest_grid){
      dhat <- rbind(dhat, data.frame(discount = dh, ug = day_grid$ug[i], rg = day_grid$rg[i], qg = xgr))
    } else {
      dhat <- rbind(dhat, data.frame(discount = dh, ug = day_grid$ug[i], qg = xgr))
    }
  }
  
  # loess smoothing
  if(loess){
    loess_model <- stats::loess(discount~qg, data = dhat)
    dhat$discount <- predict(loess_model)
  }
  dhat$yield <- -log(dhat$discount) / dhat$qg
  dhat
}



#' Estimate variances for each point on the discount function and yield curve
#' 
#' @param data A data frame; bond data to estimate discount curve from.
#' @param ugrid A numeric vector; the times at which the discount curve will be estimated.
#' @param hu A numeric vector, bandwidth parameter determining the size of the window
#' that corresponds to each time at which the discount curve is estimated,
#' @param xgrid A numeric matrix, each row represents the time-to-maturity grid
#' for the discount function at the corresponding time.
#' @param hx A numeric vector, bandwidth parameter determining the size of the window
#' that corresponds to each time-to-maturity.
#' @param perrors A dataframe with columns qdate, crspid and perror, where perror is the in-sample pricing error (residual) for the given crspid and qdate.
#' @param dhat Dataframe obtained from estimate_dhat function
#' @param cf_slist (Optional) A list of matrices, generated by calc_cf_slist.
#' 
#' @return Data frame of the variance in addition to the yield and discount rate at each combination of the provided grids.
#' \describe{
#'   \item{dhat_var}{Same as input \code{ugrid}}
#'   \item{yield_var}{Same as input \code{ugrid}}
#'   \item{discount}{Estimated discount rate}
#'   \item{ug}{Same as input \code{ugrid}}
#'   \item{xg}{Same as input \code{xgrid}}
#'   \item{yield}{Estimated yield}
#' }
#' @author Nathaniel Tomasetti
#' @export
dhat_var <- function(data, ugrid, hu, xgrid, hx, perrors, dhat, cf_slist) {
  if(missing(cf_slist)){
    cf_slist <- calc_cf_slist(data)
  }
  day_idx <- calc_day_idx(data, ugrid, hu)
  uu_window <- calc_uu_window(data,ugrid,hu)
  nday <- length(ugrid)
  # cat(identical(day_idx, a), "\n")
  # cat(identical(uu_window, b), "\n")
  # cat(identical(nday, c), "\n")
  
  
  if(is.vector(xgrid)){
    tupq_idx <- calc_tupq_idx(data, xgrid, hx)
    ux_window <- calc_ux_window(data, xgrid, hx)
    ntupq <- length(xgrid)
    
    # cat(identical(tupq_idx, d), "\n")
    # cat(identical(ux_window, e), "\n")
    # cat(identical(ntupq, f), "\n")
    # cat("111\n") ## *********************************************************************
  } else if(nrow(xgrid) == 1) {
    tupq_idx <- calc_tupq_idx(data, xgrid, hx)
    ux_window <- calc_ux_window(data, xgrid, hx)
    ntupq <- length(xgrid)
    # cat("222\n") ## *********************************************************************
  } else {
    tupq_idx <- NULL
    ux_window <- NULL
    for(i in 1:nrow(xgrid)){
      tupq_idx <- cbind(tupq_idx, calc_tupq_idx(data, xgrid[i,], hx))
      ux_window <- cbind(ux_window, calc_ux_window(data, xgrid[i, ], hx))
    }
    ntupq <- ncol(xgrid)
    # cat("333\n") ## *********************************************************************
  }

  dbar_w <- calc_w_c(nday, ntupq, day_idx, tupq_idx, ux_window, uu_window, cf_slist)

  if(!is.matrix(perrors)){
    crspID <- unique(perrors$crspid)
    qdates <- unique(perrors$qdate)
    perrorMat <- matrix(0, length(crspID), length(qdates))

    for(i in 1:length(crspID)){
      for(j in 1:length(qdates)){
        perrors[perrors$crspid == crspID[i] & perrors$qdate == qdates[j],] -> error
        if(dim(error)[1] == 0){
          perrorMat[i, j] <- NA
        } else {
          if(length(error$perror) > 1){
            perrorMat[i, j] <- mean(error$perror)
          } else {
            perrorMat[i, j] <- error$perror
          }
        }
      }
    }
    perrors <- perrorMat
  }

  var_dbar <- numeric(ntupq*nday)
  for(xu in 1:(ntupq*nday)){
    var_dbar[xu] <- sum(dbar_w[,,xu]^2) * var(perrors[dbar_w[,,xu] != 0], na.rm = TRUE)
  }


  dbar_var <- data.frame(ug = rep(ugrid, rep(ntupq, nday)), hu = rep(hu, rep(ntupq, nday)), hx = rep(hx, nday), var = var_dbar)
  if(is.vector(xgrid)){
    dbar_var$xg = rep(xgrid, nday)
  } else if(nrow(xgrid) == 1) {
    dbar_var$xg = rep(xgrid, nday)
  } else {
    dbar_var$xg = c(t(xgrid))
  }
  dbar_var %>%
    mutate(dhat_var = !!sym('var') * !!sym('hx') * !!sym('hu') * length(perrors)) %>%
    select(!!sym('ug'), !!sym('xg'), !!sym('dhat_var')) -> dbar_var
  dbar_var

  dbar_var <- right_join(dhat, dbar_var, by = c("ug" = "ug", "qg" = "xg"))
  dbar_var$yield_var = dbar_var$dhat_var / (dbar_var$qg * dbar_var$discount)^2
  dbar_var
}


